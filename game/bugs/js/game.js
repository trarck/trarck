var Player=YHBug.Player;        //初始化引擎var engine=new yhge.Engine({    canvas:"canvas",    renderer:"canvas",    timeTask:yhge.Engine.TimeTaskType.All,    interval:30,    forceInterval:false});//可以使用if(engine.enable){    //建立资源。    //建立所有shape和MorphShape(可不建立，直接使用定义)    //sprite的二种方式。第一种：都生成MovieClip,使用clone方法取得新的物体。flash导过来的资源建议使用。    //                  第二种：直接使用定义，使用的时候使用工作方法MovieClip.createMovieClip取得。此方法不适合sprite包含sprite的情况，如果包含sprite则要做缓存    //TODO 缓存shape。把shape画到一个canvas上，作为图片使用。    var bugCategories=[71,74,76,78,80];    var resources={},animations={};    for(var id in datas){        var definition=datas[id];        switch (definition.className) {            case "Shape":                resources[id]=Shape.createShape(engine.context,definition);                break;            case "MovieClip":                resources[id]=animations[id]=MovieClip.createMovieClip(engine.context,definition,resources);                break;            case "MorphShape":                resources[id]=new MorphShape(definition);                break;        }    }    game.resources=resources;    var score=0,totalBug=12,baseBug=4,incrementBug=2;    var bugs=[];    //alert("engine init sucess!");    //创建动画主时间线    var mainTimeLine=new AnimationGroup({        duration:1000/30,    });    engine.animationManager.add(mainTimeLine);    game.mainTimeLine=mainTimeLine;    //创建场景    singleSceneUpdater=SingleSceneUpdater.getInstance(engine.scheduler,engine.context);    var sceneWidth=500,sceneHeight=500;    var scene=new Scene({        width:sceneWidth,        height:sceneHeight    });    singleSceneUpdater.setScene(scene);        //创建背景    var bgImg=new Image();    bgImg.src="images/bg.jpg";    var bg=new Sprite({        texture:bgImg,        width:500,        height:500    });    scene.addChild(bg);    //创建人物    var mainPlayer=new Player({        radius:15,        speed:6,        hp:10,        solid:true,        color:"#F0F",        zOrder:10    });    //人物动画    //idle    //move    mainPlayer.addAnimationMapItemWithDirection("move",1,resources[160].clone().setScale(-1,1));//left up    mainPlayer.addAnimationMapItemWithDirection("move",2,resources[169].clone());               //up    mainPlayer.addAnimationMapItemWithDirection("move",3,resources[160].clone());               //right up    mainPlayer.addAnimationMapItemWithDirection("move",4,resources[177].clone().setScale(-1,1));//right    mainPlayer.addAnimationMapItemWithDirection("move",5,resources[182].clone().setScale(-1,1));//right down    mainPlayer.addAnimationMapItemWithDirection("move",6,resources[183].clone());               //down    mainPlayer.addAnimationMapItemWithDirection("move",7,resources[182].clone());               //left down    mainPlayer.addAnimationMapItemWithDirection("move",8,resources[177].clone());               //left    //jump    mainPlayer.addAnimationMapItem("jump",resources[137].clone());    mainPlayer.setCurrentAnimation(mainPlayer.getAnimationMapItemWithDirection("move",2));    //人物属性    mainPlayer.setPosition(sceneWidth/2,sceneHeight/2);    mainPlayer.setPosition({x:sceneWidth/2,y:sceneHeight/2});    //落地执行的动作    mainPlayer.onJumpEnd=function () {        //炸弹效果        bomp.explode();        //获取被炸的怪物        var hits=checkBomp(mainPlayer.getPosition(),bomp.getRadius()+8);        if(hits && hits.length){            //一个怪物一分            var hitNumber=hits.length;            score+=hits.length;            document.getElementById("score").innerHTML=score;            //删除死亡怪物。            //TODO 怪物池。死亡的怪物直接进怪物池。            for(var i=0;i<hitNumber;i++){                var index=bugs.indexOf(hits[i]);                scene.removeChild(hits[i]);                if(index>-1) bugs.splice(index,1);            }            //分数大于100，增加难度            if(score>100) {                var base=parseInt(score/50);                totalBug=12+base*3;                baseBug=4+base*2;                incrementBug=2+base;            }        }    };    scene.addChild(mainPlayer);    //创建怪物    createMonsters2(totalBug,baseBug,incrementBug);        //全局逻辑处理    var lastHitTime=0;    engine.scheduler.addTask(function(delta) {        //createMonsters2(totalBug);        //定时更新。目前更新逻辑放在外面，由于游戏逻辑部分比较简单。        for(var i in bugs) bugs[i].update(delta);        mainPlayer.update(delta);        if(bomp) {            //bomp与player未作任何关联，位置在这里处理。            bomp.setPosition(mainPlayer.getPosition());            bomp.update(delta);        }        //检测人物是否被虫子攻击(撞到人或炸弹都算人物受伤)        //TODO 如果有炸弹，则炸弹消失。        if(!mainPlayer.isInvincible()){            var radius=mainPlayer.isPressing()?bomp.getRadius():mainPlayer.getRadius();            if(checkColl(mainPlayer.getPosition(),radius+8)){                //使用时间戳来避免，碰撞的反复检测。                //TODO 使用碰撞事件。碰撞开始，碰撞中，碰撞结束。                var nowHitTime=new Date().getTime();                if(!lastHitTime ||nowHitTime-lastHitTime>1000){                    var hp=mainPlayer.getHp()-1;                    document.getElementById("hp").innerHTML=hp;                    if(hp>0){                        mainPlayer.setHp(hp);                    }else{                        gameOver();                    }                    lastHitTime=nowHitTime;                }            }else{                lastHitTime=0;            }        }    },Scheduler.Update,this);    engine.timer.setInterval(function () {        createMonsters2(totalBug,baseBug,incrementBug);    },500);    //mouse event    var canvas=document.getElementById("canvas");    var timer,bomp,radius=10,maxRadius=135;    var offset=getOffset(canvas);    canvas.onmousedown=function(e){        var x=e.pageX-offset.left,            y=e.pageY-offset.top;        console.log("onmousedown :",mainPlayer._state);        mainPlayer.press();        if(mainPlayer.isPressing()&&!mainPlayer.isJumping()){            bomp=new YHBug.Bomp({radius:10,minRadius:10,maxRadius:maxRadius,color:"#F00",solid:true,zOrder:4,opacity:0.4});            bomp.setPosition(x,y);            bomp.onExplodeEnd=function () {                mainPlayer.setWaitForExploded(false);                scene.removeChild(bomp);                bomp=null;                //createMonsters2(totalBug);            };            bomp.grow();            scene.addChild(bomp);        }    };    var colors=["#C00","#C00","#C00","#C00","#300","#600","#900","#C00","#F00","#FFF"].reverse();    canvas.onmouseup=function(e){       console.log("onmouseup:",mainPlayer._state,mainPlayer._pressing);       mainPlayer.jump();       if(mainPlayer.isJumping()&&bomp){           bomp.setVisible(false);           bomp.normal();       }    };    canvas.onmousemove=function(e){         var x=e.pageX-offset.left,            y=e.pageY-offset.top;         mainPlayer.setTargetPosition({x:x,y:y});         //if(bomp) bomp.setPosition(x,y);    };    canvas.onmouseout=function(e){             };    canvas.onclick=function(e){            };}else{    alert("engine init failure!");}function createMonsters(num) {    for(var i=0;i<num;){        var ranx = Math.random()*sceneWidth;        var rany = Math.random()*sceneHeight;        if (ranx < 200 || ranx > 300){            if (rany < 200 || rany > 300){                var bug=new YHBug.Monster({color:"#0F0"});                bug.setPosition(ranx,rany);                bug.setTarget({x:sceneWidth/2,y:sceneHeight/2});                scene.addChild(bug);                bugs.push(bug);                i++            }        }    }}function createMonsters2(total,base,num) {    var current=bugs.length,i;    if(current<total){        if(current<base) createFixMonsters(base-current);        i=0;        while(i++<num) createMonster();    }    document.getElementById("bugCount").innerHTML=bugs.length;}function createMonster() {    var ret=false;    var ranx = Math.random()*sceneWidth;    var rany = Math.random()*sceneHeight;    if (ranx < 200 || ranx > 300){        if (rany < 200 || rany > 300){            var bug=new YHBug.Monster({color:"#0F0"});            bug.setPosition(ranx,rany);            bug.setCategory(bugCategories[Math.floor(Math.random()*5)]);            bug.setTarget({x:sceneWidth/2,y:sceneHeight/2});            scene.addChild(bug);            bugs.push(bug);            ret=true;        }    }    return ret;}function createFixMonsters(num) {    for(var i=0;i<num;){        var ranx = Math.random()*sceneWidth;        var rany = Math.random()*sceneHeight;        if (ranx < 200 || ranx > 300){            if (rany < 200 || rany > 300){                var bug=new YHBug.Monster({color:"#0F0"});                bug.setPosition(ranx,rany);                bug.setCategory(bugCategories[Math.floor(Math.random()*5)]);                bug.setTarget({x:sceneWidth/2,y:sceneHeight/2});                scene.addChild(bug);                bugs.push(bug);                i++;            }        }    }}function checkBomp(position,radius) {    var r2=radius*radius,hits=[],bug,p;    for(var i=0,l=bugs.length;i<l;i++){        bug=bugs[i];        p=bug.getPosition();        dx=p.x-position.x;        dy=p.y-position.y;        if(dx*dx+dy*dy<=r2){            hits.push(bug);        }    }    return hits;}function checkColl(position,radius) {    var r2=radius*radius,bug,p,dx,dy;    for(var i=0,l=bugs.length;i<l;i++){        bug=bugs[i];        p=bug.getPosition();        dx=p.x-position.x;        dy=p.y-position.y;        if(dx*dx+dy*dy<=r2) return true;    }    return false;}function gameStart() {    score=0;    totalBug=12;    baseBug=4;    incrementBug=2;    bugs=[];    mainPlayer.setHp(10);    document.getElementById("hp").innerHTML=10;    //时间开始    engine.scheduler.run();    //创建怪物    createMonsters2(totalBug,baseBug,incrementBug);    //隐藏gameover    document.getElementById("gameOverView").style.display="none";}function gameOver() {    //停止时间    engine.scheduler.stop();    //删除怪物    for(var i=0,l=bugs.length;i<l;i++){       scene.removeChild(bugs[i]);    }    bugs=[];    //显示gameover    document.getElementById("gameOverView").style.display="";}var n=singleSceneUpdater.updateTimes;var fps=document.getElementById("fps");setInterval(function  () {    fps.innerHTML=singleSceneUpdater.updateTimes-n;    n=singleSceneUpdater.updateTimes;},1000);function getOffset(ele){    var left=ele.offsetLeft,top=ele.offsetTop;    var p=ele.offsetParent;    while(p){        left+=p.offsetLeft;        top+=p.offsetTop;        p=p.offsetParent;    }    return {left:left,top:top};}